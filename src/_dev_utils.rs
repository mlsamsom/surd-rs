use ndarray::{Array, Array2};
use ndarray_rand::{rand::SeedableRng, rand_distr::Normal, RandomExt};
use rand_isaac::Isaac64Rng;

/// Generates a cyclical correlated dataset that is generated by
pub fn mediator(n: usize, seed: u64) -> Array2<f64> {
    let mut q: Array2<f64> = Array::zeros((3, n));
    let mut rng = Isaac64Rng::seed_from_u64(seed);
    let w: Array2<f64> = Array::random_using(
        (3, n),
        Normal::new(0.0, 1.0).expect("Failed to create normal dist"),
        &mut rng,
    );

    for n in 0..n - 1 {
        q[[0, n + 1]] = f64::sin(q[[1, n]]) + 0.001 * w[[0, n]];
        q[[1, n + 1]] = f64::cos(q[[2, n]]) + 0.01 * w[[1, n]];
        q[[2, n + 1]] = 0.5 * q[[2, n]] + 0.1 * w[[2, n]];
    }

    q
}

pub fn confounder(n: usize, seed: u64) -> Array2<f64> {
    let mut q: Array2<f64> = Array::zeros((3, n));
    let mut rng = Isaac64Rng::seed_from_u64(seed);
    let w: Array2<f64> = Array::random_using(
        (3, n),
        Normal::new(0.0, 1.0).expect("Failed to create normal dist"),
        &mut rng,
    );

    for n in 0..n - 1 {
        q[[0, n + 1]] = f64::sin(q[[0, n]] + q[[2, n]]) + 0.01 * w[[0, n]];
        q[[1, n + 1]] = f64::cos(q[[1, n]] - q[[2, n]]) + 0.01 * w[[1, n]];
        q[[2, n + 1]] = 0.5 * q[[2, n]] + 0.1 * w[[2, n]];
    }
    q
}

pub fn synergistic_collider(n: usize, seed: u64) -> Array2<f64> {
    let mut q: Array2<f64> = Array::zeros((3, n));
    let mut rng = Isaac64Rng::seed_from_u64(seed);
    let w: Array2<f64> = Array::random_using(
        (3, n),
        Normal::new(0.0, 1.0).expect("Failed to create normal dist"),
        &mut rng,
    );

    for n in 0..n - 1 {
        q[[0, n + 1]] = f64::sin(q[[1, n]] * q[[2, n]]) + 0.001 * w[[0, n]];
        q[[1, n + 1]] = 0.5 * q[[1, n]] + 0.1 * w[[1, n]];
        q[[2, n + 1]] = 0.5 * q[[2, n]] + 0.1 * w[[2, n]];
    }

    q
}

pub fn redundant_collider(n: usize, seed: u64) -> Array2<f64> {
    let mut q: Array2<f64> = Array::zeros((3, n));
    let mut rng = Isaac64Rng::seed_from_u64(seed);
    let w: Array2<f64> = Array::random_using(
        (3, n),
        Normal::new(0.0, 1.0).expect("Failed to create normal dist"),
        &mut rng,
    );

    for n in 0..n - 1 {
        q[[0, n + 1]] = 0.3 * q[[0, n]] + (f64::sin(q[[1, n]] * q[[2, n]]) + 0.001 * w[[0, n]]);
        q[[1, n + 1]] = 0.5 * q[[1, n]] + 0.1 * w[[1, n]];
        q[[2, n + 1]] = q[[1, n + 1]];
    }

    q
}
